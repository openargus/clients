/*
 * Gargoyle Client Software. Tools to read, analyze and manage Argus data.
 * Copyright (c) 2000-2019 QoSient, LLC
 * All rights reserved.
 *
 * THE ACCOMPANYING PROGRAM IS PROPRIETARY SOFTWARE OF QoSIENT, LLC,
 * AND CANNOT BE USED, DISTRIBUTED, COPIED OR MODIFIED WITHOUT
 * EXPRESS PERMISSION OF QoSIENT, LLC.
 *
 * QOSIENT, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL QOSIENT, LLC BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 *
 *  racontext - A utility to find the network "contexts" in argus records
 *  generated by a single sensor.
 *
 *    1.  find temporal boundaries - beginning, "large" gaps, end,
 *        find/count SID(s),
 *    2.  split candidate ranges on dhcp lease boundaries (can come from some infrastructure sensor)
 *    2a. split candidate ranges by link-state event records, when available.
 *    3.  mark potential context boundaries
 *    4.  collect context attribute values for each candidate context
 *    5.  search context database for each candidate.  If no match
 *        found, generate new context uuid and insert into database.
 *        Emit event record with context times and identifier.
 *
 *  By default, racontext uses the range of times found in the input flow
 *  records to limit the dhcp database search.  The user can override this
 *  behavior with the -t <timerange> option.
 *
 *  (There are some extraneous spaces in the command below to avoid
 *  terminating the C comment.)
 *
 *  For development purposes, a sample invocation:
 *    % bin/racontext -X -f /tmp/conf -r mysql://root@localhost/dhcpFlows \
 *      -r /home/argus/uploads/60834d56-40b6-50ee-7ebe-5565188abd82/D853/2019/01/ * /argus.2019.01.* \
 *      -Mtime 1d | \
 *      gawk '/context/{$3 = strftime("%c   ", $3); \
 *                      $5 = strftime("%c   ", $5);} \
 *            {print}'
 *
 *  /tmp/conf contains:
 *     SILENCE_DURARTION_SEC=120
 *     CLIENTMAC="98:01:a7:a7:3b:bf"
 *
 *  Author: Eric Kinzie <eric@qosient.com>
 */

#ifdef HAVE_CONFIG_H
# include "argus_config.h"
#endif

#include <limits.h>
#include <arpa/inet.h>
#include <sys/syslog.h>
#include <sys/time.h>
#include <stdbool.h>
#include "argus_util.h"
#include "argus_client.h"
#include "argus_main.h"
#include "argus_mysql.h"
#include "ramysqlinit.h"
#include "racontext.h"
#include "racontext_process_dhcp.h"
#include "racontext_attribute_flow.h"
#include "racontext_insert_known_context.h"
#include "racontext_index_known_context.h"

#include "argus_dhcp.h"
#include "rabootp.h"

#if defined(CYGWIN)
# include <sys/cygwin.h>
# define USE_IPV6
#endif

#ifdef ARGUSDEBUG
# define DEBUGLOG(lvl, fmt...) ArgusDebug(lvl, fmt)
#else
# define DEBUGLOG(lvl, fmt...)
#endif

struct ArgusInput *ArgusInput = NULL;
MYSQL *RaMySQL = NULL;

typedef struct _str_t {
   char *str;
   size_t len;		/* bytes used */
   size_t remain;	/* bytes remaining */
} str_t;

typedef enum _ConfigOptTypes {
   CONFIG_TYPE_YESNO,
   CONFIG_TYPE_UINT,
   CONFIG_TYPE_STR,
   CONFIG_TYPE_INET,
   CONFIG_TYPE_ETHER,
} ConfigOptTypes;

enum ConfigOpts {
   CONFIG_SILENCE_DURARTION_SEC = 0, /* longest allowable silence */
   CONFIG_CONTEXT_MIN_DURATION_SEC, /* shortest allowable context duration */
   CONFIG_DATABASE_URI_DHCP,
   CONFIG_DATABASE_URI_CTX,
   CONFIG_CLIENTMAC,
};

static char *ConfigResourceFileStr[] = {
   "SILENCE_DURARTION_SEC=",
   "CONTEXT_MIN_DURATION_SEC=",
   "DATABASE_URI_DHCP=",
   "DATABASE_URI_CTX=",
   "CLIENTMAC=",
};

static const size_t CONFIG_RCITEMS =
   sizeof(ConfigResourceFileStr)/sizeof(ConfigResourceFileStr[0]);

static configuration_t global_config = {
   .silence_duration_sec = 60,
   .context_min_duration_sec = 15,
};
static struct RaBinProcessStruct *RaBinProcess;
struct ArgusParserStruct *ArgusParser;
static int noconf = 0;
static struct sid_tree *RacontextSidtree;
static struct ArgusTime global_startime = { INT_MAX, 0 };
static struct ArgusTime global_lasttime;

#if defined(CYGWIN) || defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
#  include <windows.h>
# define REG_INIT(resstr, v, fieldname)				\
   { .valuename = (resstr),					\
     .valuetype = (v),						\
     .offset = offsetof(struct _configuration_t, fieldname),	\
   }

static int __parse_str(const char * const src, char **dst, size_t max);
static int __parse_uint(const char * const src, unsigned int *dst);
static int __parse_yesno(const char * const src, unsigned char *dst);
static int __parse_network_address(const char * const src,
                                   struct sockaddr_storage *dst);
static int __parse_ether_address(const char * const src,
                                 struct ether_addr **dst);
struct {
   const char * const valuename;
   ConfigOptTypes valuetype;
   size_t offset;
} ConfigWindowsRegistryValues[] = {
   REG_INIT("SILENCE_DURARTION_SEC", CONFIG_TYPE_UINT, silence_duration_seconds),
   REG_INIT("CONTEXT_MIN_DURATION_SEC", CONFIG_TYPE_UINT, context_min_duration_seconds),
   REG_INIT("DATABASE_URI_DHCP", CONFIG_TYPE_STR, database_uri_dhcp),
   REG_INIT("DATABASE_URI_CTX", CONFIG_TYPE_STR, database_uri_ctx),
   REG_INIT("CLIENTMAC", CONFIG_TYPE_ETHER, clientmac),
};
static const size_t CONFIG_REGITEMS =
   sizeof(ConfigWindowsRegistryValues)/
   sizeof(ConfigWindowsRegistryValues[0]);

/* must have valid hkey */
static int
__fetch_registry_value(HKEY hkey, int index, configuration_t *config)
{
   int rv;
   char *tmp;
   const char * const valuename =
    ConfigWindowsRegistryValues[index].valuename;
   char **strval = (char **)(((char *)config) +
    ConfigWindowsRegistryValues[index].offset);
   unsigned int *intval = (unsigned int *)(((char *)config) +
    ConfigWindowsRegistryValues[index].offset);
   unsigned char *ucval = (unsigned char *)(((char *)config) +
    ConfigWindowsRegistryValues[index].offset);
   struct sockaddr_storage *addrval =
    (struct sockaddr_storage *)(((char *)config) +
    ConfigWindowsRegistryValues[index].offset);
   struct ether_addr **etherval =
    (struct ether_addr **)(((char *)config) +
    ConfigWindowsRegistryValues[index].offset);

   switch (ConfigWindowsRegistryValues[index].valuetype) {
      case CONFIG_TYPE_STR:
         tmp = ArgusMalloc(PATH_MAX);
         rv = ArgusWindowsRegistryGetSZ(hkey, valuename, tmp, PATH_MAX-1);
         if (rv == 0)
            rv = __parse_str(tmp, strval, PATH_MAX);

         ArgusFree(tmp);
         break;

      case CONFIG_TYPE_UINT:
         {
         long long tmpll;

         rv = ArgusWindowsRegistryGetQWORD(hkey, valuename, &tmpll);
         if (rv == 0)
            *intval = (unsigned int)tmpll;
         }
         break;

      case CONFIG_TYPE_YESNO:
         tmp = ArgusMalloc(5);
         rv = ArgusWindowsRegistryGetSZ(hkey, valuename, tmp, 4);
         if (rv == 0)
            rv = __parse_yesno(tmp, ucval);

         ArgusFree(tmp);
         break;

      case CONFIG_TYPE_INET:
         tmp = ArgusMalloc(PATH_MAX);
         rv = ArgusWindowsRegistryGetSZ(hkey, valuename, tmp, PATH_MAX-1);
         if (rv == 0)
            rv = __parse_network_address(tmp, addrval);

         ArgusFree(tmp);
         break;

      case CONFIG_TYPE_ETHER:
         tmp = ArgusMalloc(PATH_MAX);
         rv = ArgusWindowsRegistryGetSZ(hkey, valuename, tmp,
         if (rv == 0)
            rv = __parse_ether_address(tmp, etherval);
         ArgusFree(tmp);
   }
   return rv;
}

static void __fetch_registry_values(HKEY hkey, configuration_t *config)
{
   size_t i;

   for (i = 0; i < CONFIG_REGITEMS; i++)
      if (__fetch_registry_value(hkey, i, config) == 0)
         DEBUGLOG(2, "updated config from registry item %s\n",
                  ConfigWindowsRegistryValues[i].valuename)
         ;
}
#endif

#if !defined(CYGWIN)
# if defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
typedef unsigned long useconds_t;
int usleep(useconds_t usec)
{
   HANDLE timer;
   LARGE_INTEGER ft;

   ft.QuadPart = -(10 * (__int64)usec);

   timer = CreateWaitableTimer(NULL, TRUE, NULL);
   SetWaitableTimer(timer, &ft, 0, NULL, NULL, 0);
   WaitForSingleObject(timer, INFINITE);
   CloseHandle(timer);
   return 0;
}
# endif /* _MSC_VER... */
#endif /* CYGWIN */

static int
__parse_str(const char * const src, char **dst, size_t max)
{
   int used;

   if (*dst != NULL)
      ArgusFree(*dst);

   *dst = ArgusMalloc(max);
   if (*dst == NULL)
      ArgusLog(LOG_ERR, "%s: unable to allocate memory\n", __func__);

   used = snprintf(*dst, max, "%s", src);
   if (used < 0 || used >= max) {
      ArgusFree(*dst);
      *dst = NULL;
      return -1;
   }

   *dst = ArgusRealloc(*dst, used+1);
   return 0;
}

static int
__parse_uint(const char * const src, unsigned int *dst)
{
   unsigned long tmpdst;
   char *endptr;

   tmpdst = strtoul(src, &endptr, 0);

   if (tmpdst == ULONG_MAX && errno == ERANGE)
      return -1;

   if (src && (src != endptr)) {
      *dst = (unsigned int)tmpdst;
      return 0;
   }

   return -1;
}

static int __parse_ether_address(const char * const src,
                                 struct ether_addr **dst)
{
   if (*dst != NULL)
      ArgusFree(*dst);

   *dst = ArgusMalloc(sizeof(struct ether_addr));
   if (*dst == NULL)
      ArgusLog(LOG_ERR, "%s: unable to allocate memory\n", __func__);

   if (__ether_aton(src, (unsigned char *)(*dst)) < 0) {
      ArgusFree(*dst);
      *dst = NULL;
      return -1;
   }

   return 0;
}

#ifdef notdef
static int
__parse_yesno(const char * const src, unsigned char *dst)
{
   if (strcasecmp(src, "yes") == 0)
      *dst = 1;
   else {
      *dst = 0;
      if (strcasecmp(src, "no") != 0)
         return -1;
   }
   return 0;
}

static int
__parse_network_address(const char * const src, struct sockaddr_storage *dst)
{
   size_t slen = strlen(src);
   struct in_addr addr4;
   struct in6_addr addr6;
   int af = AF_INET;

   if (slen > NAME_MAX)
      return -1;

   if (inet_pton(AF_INET, src, &addr4) != 1) {
      if (inet_pton(AF_INET6, src, &addr6) != 1)
         return -1;
      else
         af = AF_INET6;
   }

   dst->ss_family = af;
   if (af == AF_INET)
      ((struct sockaddr_in *)dst)->sin_addr = addr4;
   else
      ((struct sockaddr_in6 *)dst)->sin6_addr = addr6;
   return 0;
}
#endif

static int
RacontextConfigureParse(struct ArgusParserStruct *parser, int linenum,
                        char *optarg, int quoted, int idx)
{
   int retn = 0;

   switch (idx) {
      case CONFIG_SILENCE_DURARTION_SEC:
         retn = __parse_uint(optarg, &global_config.silence_duration_sec);
         break;
      case CONFIG_CONTEXT_MIN_DURATION_SEC:
         retn = __parse_uint(optarg, &global_config.context_min_duration_sec);
         break;
      case CONFIG_DATABASE_URI_DHCP:
         retn = __parse_str(optarg, &global_config.database_uri_dhcp, NAME_MAX);
         break;
      case CONFIG_DATABASE_URI_CTX:
         retn = __parse_str(optarg, &global_config.database_uri_ctx, NAME_MAX);
         break;
      case CONFIG_CLIENTMAC:
         retn = __parse_ether_address(optarg, &global_config.clientmac);
         break;
   }

   if (retn)
      ArgusLog(LOG_ERR, "parse error line %d\n", linenum);

   return 0;
}

static int
RacontextConfigure(struct ArgusParserStruct * const parser,
                   configuration_t *config)
{
   struct stat statbuf;
#if defined(CYGWIN) || defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
   HKEY hkey; /* used by Windows systems to read config values */
#endif

   if (noconf == 0 && stat(SYSCONFDIR "/racontext.conf", &statbuf) == 0) {
      RaParseResourceFile(parser, SYSCONFDIR "/racontext.conf",
                          ARGUS_SOPTIONS_IGNORE, ConfigResourceFileStr,
                          CONFIG_RCITEMS, RacontextConfigureParse);
   }

   if (parser->ArgusFlowModelFile != NULL) {
      RaParseResourceFile(parser, parser->ArgusFlowModelFile,
                          ARGUS_SOPTIONS_IGNORE, ConfigResourceFileStr,
                          CONFIG_RCITEMS, RacontextConfigureParse);

   }

#if defined(CYGWIN) || defined(_MSC_VER) || defined(__MINGW32__) || defined(__MINGW64__)
   if (noconf == 0 &&
       ArgusWindowsRegistryOpenKey(ARGUS_CLIENTS_REGISTRY_HKEY,
                                   ARGUS_CLIENTS_REGISTRY_KEYNAME "\\racontext",
                                   &hkey) == 0) {
      __fetch_registry_values(hkey, config);
      ArgusWindowsRegistryCloseKey(hkey);
   }
#endif

   return 0;
}

static void
RacontextConfigureFree(configuration_t *config)
{
   if (config->database_uri_dhcp) {
      ArgusFree(config->database_uri_dhcp);
      config->database_uri_dhcp = NULL;
   }
   if (config->database_uri_ctx) {
      ArgusFree(config->database_uri_ctx);
      config->database_uri_ctx = NULL;
   }
   if (config->clientmac) {
      ArgusFree(config->clientmac);
      config->clientmac = NULL;
   }
}

void
RacontextFree(struct racontext *ctx)
{
   if (ctx->attrs)
      RacontextAttrTreeFree(ctx->attrs);

   ArgusFree(ctx);
}

struct racontext *
RacontextAlloc(void)
{
   struct racontext *rac;

   rac = ArgusCalloc(1, sizeof(struct racontext));
   if (rac == NULL)
      return NULL;

   rac->attrs = RacontextAttrTreeAlloc();
   if (rac->attrs == NULL) {
      ArgusFree(rac);
      rac = NULL;
   }
   return rac;
}


void RaArgusInputComplete (struct ArgusInput *input) { return; }
void ArgusClientTimeout (void) { return; }
void usage (void) { return; }
int RaSendArgusRecord(struct ArgusRecordStruct *argus) { return 0; }
void ArgusWindowClose(void) { return; }
void RaSQLQuerySecondsTable (unsigned int start, unsigned int stop) { return; }

static void
RacontextUpdateTimeRange(struct ArgusRecordStruct *argus)
{
   struct ArgusTimeObject *time;

   time = (struct ArgusTimeObject *)argus->dsrs[ARGUS_TIME_INDEX];
   if (time == NULL)
      return;

   if (time->src.start.tv_sec) /* do we need this check? */
      if (timercmp(&global_startime, &time->src.start, >))
         global_startime = time->src.start;

   if (time->dst.start.tv_sec)
      if (timercmp(&global_startime, &time->dst.start, >))
         global_startime = time->dst.start;

   if (time->src.start.tv_sec)
      if (timercmp(&global_lasttime, &time->src.start, <))
         global_lasttime = time->src.start;

   if (time->src.end.tv_sec)
      if (timercmp(&global_lasttime, &time->src.end, <))
         global_lasttime = time->src.end;

   if (time->dst.start.tv_sec)
      if (timercmp(&global_lasttime, &time->dst.start, < ))
         global_lasttime = time->dst.start;

   if (time->dst.end.tv_sec)
      if (timercmp(&global_lasttime, &time->dst.end, < ))
         global_lasttime = time->dst.end;
}

void
ArgusClientInit(struct ArgusParserStruct *parser)
{
   struct ArgusModeStruct *mode;
   int cmdres;
   int splitmode = -1;

   if (strstr(parser->ArgusProgramArgs, "-X"))
      noconf++;

   if ((mode = parser->ArgusModeList) != NULL) {
      while (mode) {
         mode = RaParseSplitMode(parser, &RaBinProcess, mode, &splitmode);
      }
   }

   if (RaBinProcess == NULL)
      ArgusLog(LOG_ERR, "must supply a time mode (-Mtime ...)\n");

   RacontextSidtree = SidtreeAlloc();
   if (RacontextSidtree == NULL)
      ArgusLog(LOG_ERR, "unable to allocate SID tree\n");

   cmdres = RacontextConfigure(parser, &global_config);
   if (cmdres) {
      ArgusLog(LOG_ERR, "invalid configuration\n");
   }
   RaMySQLInit(parser);

   parser->ArgusPassNum = 2;
}

/* pass 2 happens before pass one . . . */
static void
RaProcessRecordPass2(struct ArgusParserStruct *parser,
                     struct ArgusRecordStruct *argus,
                     struct RacontextTree *e)
{
   struct racontext *ctx = NULL;

   if (e == NULL) {
      e = RacontextTreeAlloc(parser, argus);
      if (e == NULL)
         ArgusLog(LOG_ERR, "%s unable to allocate context tree\n");
      SidtreeInsert(RacontextSidtree, e);
   }
   RacontextTreeAppend(e, argus, &global_config, &ctx);
   RacontextUpdateTimeRange(argus);
}

static void
RaProcessRecordPass1(struct ArgusParserStruct *parser,
                     struct ArgusRecordStruct *argus,
                     struct RacontextTree *rct)
{
   struct racontext *ctx = NULL;
   struct ArgusTimeObject *time;
   struct timeval when;

   if (rct == NULL)
      ArgusLog(LOG_ERR, "%s: no context tree?\n", __func__);

   time = (struct ArgusTimeObject *)argus->dsrs[ARGUS_TIME_INDEX];
   if (time == NULL)
      return;

   when.tv_sec = time->src.start.tv_sec;
   when.tv_usec = time->src.start.tv_usec;
   ctx = RacontextTreeFind(rct, &when);
   if (ctx)
      RacontextAttributeFlowUpdate(ctx, argus);
}

void
RaProcessRecord(struct ArgusParserStruct *parser,
                struct ArgusRecordStruct *argus)
{
   struct RacontextTree *e;
   unsigned char type = argus->hdr.type & 0xf0;

   if (type != ARGUS_NETFLOW && type != ARGUS_FAR)
      return;

   e = NULL;
   SidtreeFindByRecordStruct(RacontextSidtree, &e, parser, argus);

   if (parser->ArgusPassNum == 2)
      RaProcessRecordPass2(parser, argus, e);
   else if (parser->ArgusPassNum == 1)
      RaProcessRecordPass1(parser, argus, e);
}

int
RaOnePassComplete(void) {
   /* make sure this is the right pass */
   if (ArgusParser->ArgusPassNum != 1)
      return 1;

   if (!ArgusParser->tflag) {
      ArgusParser->startime_t.tv_sec = global_startime.tv_sec;
      ArgusParser->startime_t.tv_usec = global_startime.tv_usec;
      ArgusParser->lasttime_t.tv_sec = global_lasttime.tv_sec;
      ArgusParser->lasttime_t.tv_usec = global_lasttime.tv_usec;
   }

   if (RaMySQL) {
      RacontextProcessDhcp(ArgusParser, &global_config, RaBinProcess,
                           RacontextSidtree, RaMySQL);
   }

   return 1;
}

void RaParseComplete(int sig)
{
   if (sig < 0)
      return;

   if (ArgusParser->RaParseCompleting++)
      return;

   if (KnownContextSQLCreateTable(ArgusParser, RaMySQL,
                                  contexts_table_name) < 0)
      ArgusLog(LOG_INFO, "failed to create context index table %s\n",
               contexts_table_name);

   if (RacontextIndexSQLCreateTable(ArgusParser, RaMySQL,
                                  index_table_name) < 0)
      ArgusLog(LOG_INFO, "failed to create context index table %s\n",
               index_table_name);

   SidtreeScore(ArgusParser, RaMySQL, RacontextSidtree);
   SidtreeForeach(RacontextSidtree, RacontextTreePullup, NULL);
   SidtreeDump(RacontextSidtree);
   SidtreeFree(RacontextSidtree);
   mysql_close(RaMySQL);
   RaMySQL = NULL;
   RacontextConfigureFree(&global_config);
}
